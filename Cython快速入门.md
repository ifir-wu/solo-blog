title: Cython快速入门
date: '2019-09-09 09:22:59'
updated: '2019-09-09 09:34:41'
tags: [Cython]
permalink: /articles/2019/09/09/1567992179932.html
---
![](https://img.hacpai.com/bing/20190425.jpg?imageView2/1/w/960/h/540/interlace/1/q/100) 


## 使用Jupyter笔记本

1. 从Jupyter笔记本中加载拓展：

   IN[1]:

   ```python
   %load_ext Cython
   ```

2. 然后，在单元格前面使用`%%cython`魔法命令来标记和编译单元格，如：

   IN[2]:

   ```cython
   %%cython
   cdef int a = 0
   for i in range(10):
       a += i
   print(a)
   ```

   ```
   45
   ```

   可以通过传递`--annotate`选项来显示Cython的代码分析：

   IN[3]:

   ```cython
   %%cython --annotate
   cdef int a = 0
   for i in range(10):
       a += i
   print(a)
   ```

   ```
   45
   ```

   OUT[3]

   ```cython
   Generated by Cython 0.29.6
   Yellow lines hint at Python interaction.
   Click on a line that starts with a "`+`" to see the C code that Cython generated for it.
   +1: cdef int a = 0
   +2: for i in range(10):
   +3:     a += i
   +4: print(a)
   ```

   如果某行为白色，则表示该行生成的代码不与Python交互，因此将以与普通C代码一样快的速度运行。黄色越深，该行与Python交互越多。这些行通常可以在Python对象上运行，引发异常，或执行其他类型的高级操作，而不是可以轻松转换为简单快速的C代码。若函数声明和返回使用Python解释器，则这些行是黄色的。

   单击以“+”开头的行，可以查看Cython为其生成的C代码。

## 用一个简单的例子来解释如何包装纯C代码

1. hello.h

   ```C
   #ifndef HELLO_H
   #define HELLO_H
   
   void hello(char* s);
   
   #endif
   ```

2. hello.c

   ```c
   #include <stdio.h>
   #include "hello.h"
   
   void hello(char* s){
     printf("hello %s!", s);
   }
   ```

3. pyhello.pyx（与前面的C代码文件`hello.c`不能同名，因为在编译`.pyx`文件时会生成与`.pyx`同名的C文件）

   ```cython
   # distutils: sources = hello.c      # 指定hello.h的源代码文件的路径，这里在同路径下
                                       # 并将自动编译

   cdef extern from "hello.h":         # 指定要从hello.h中导入的内容，一般可 以直接复制粘贴
       void hello(char* s)
   
   def hello_text(s):                  # 将导入的C代码封装，以供python交互
       hello(s)
   ```

4. setup.py

   ```python
   from distutils.core import setup
   from distutils.extension import Extension
   from Cython.Build import cythonize
   
   setup(ext_modules = cythonize([Extension("pyhello", ["pyhello.pyx"])]))
   ```

5. 在同一目录下运行cmd，输入以下任一命令：

   ```powershell
   python setup.py build_ext -i
   ```

   或

   ```powershell
   python setup.py build_ext --inplace
   ```

   控制台输出编译信息，大概为：

   ```powershell
   Compiling pyhello.pyx because it changed.
   [1/1] Cythonizing pyhello.pyx
   D:\ProgramData\Anaconda3\lib\site-packages\Cython\Compiler\Main.py:367: FutureWarning: Cython directive 'language_level' not set, using 2 for now (Py2). This will change in a later release! File: E:\VSCode\Cython\pyhello.pyx
     tree = Parsing.p_module(s, pxd, full_module_name)
   running build_ext
   building 'hello' extension
   creating build
   creating build\temp.win-amd64-3.7
   creating build\temp.win-amd64-3.7\Release
   D:\ProgramData\Anaconda3\Library\mingw-w64\bin\gcc.exe -mdll -O -Wall -DMS_WIN64 -ID:\ProgramData\Anaconda3\include -ID:\ProgramData\Anaconda3\include -c pyhello.c -o build\temp.win-amd64-3.7\Release\pyhello.o
   D:\ProgramData\Anaconda3\Library\mingw-w64\bin\gcc.exe -mdll -O -Wall -DMS_WIN64 -ID:\ProgramData\Anaconda3\include -ID:\ProgramData\Anaconda3\include -c hello.c -o build\temp.win-amd64-3.7\Release\hello.o
   writing build\temp.win-amd64-3.7\Release\hello.cp37-win_amd64.def
   D:\ProgramData\Anaconda3\Library\mingw-w64\bin\gcc.exe -shared -s build\temp.win-amd64-3.7\Release\pyhello.o build\temp.win-amd64-3.7\Release\hello.o build\temp.win-amd64-3.7\Release\hello.cp37-win_amd64.def -LD:\ProgramData\Anaconda3\libs -LD:\ProgramData\Anaconda3\PCbuild\amd64 -lpython37 -lmsvcr140 -o E:\VSCode\Cython\hello.cp37-win_amd64.pyd
   ```

   解释如下：

   > 第2行表示有个一`.pyx`转化为`.c`文件，存放在与`.pyx`相同的目录下；
   > 第3-4行出现了一个警告（一会儿再解释）；
   > 第5行开始编译链接生成的C文件（`pyhello.c`）和自己写的C文件(`hello.c`)；
   > 第7-9行创建了一些文件夹用于存放编译的文件；
   > 第10行编译`pyhello.c`为`pyhello.o`并存放在第9行创建的目录下；
   > 第11行编译`hello.c`为`hello.o`并存放在第9行创建的目录下；
   > 第12行生成了一个`.def`文件存放在第9行创建的目录下；
   > 第13行生成的`.pyd`是编译好的动态链接库，以供python调用。

   其中第3行出现的警告为：

   > FutureWarning: Cython directive 'language_level' not set, using 2 for now (Py2). 

   从文章《[What does language_level in setup.py for cython do?](https://stackoverflow.com/questions/54900723/what-does-language-level-in-setup-py-for-cython-do)》中了解到，该警告的意思貌似是需要指定Cython将`.pyx`中的Python代码解释为Python2还是Python3，如果不指定，那么将解释为Python2代码。该文章末尾还举了例子来解释，但我还没有验证。

   要解决该警告，需要修改`setup.py`，如果是Python3，则在`cythonize`函数中加入`compiler_directives = {'language_level': 3}`参数即可消除该警告；如果是python2，可指定`language_level`为2；也可以选择忽略该警告，那么将默认使用Python2去解释代码。

   下面的`setup.py`，不仅消除了警告，还修改了部分内容（第9行，第14行，第16行）。

   ```python
   from distutils.core import setup
   from distutils.extension import Extension
   from Cython.Build import cythonize
   
   setup(
       name="My hello app",   # 指定setup的名字
       ext_modules = cythonize(
           [
               Extension(
                   "hello",   # 生成的动态链接库.pyd的名字，该名字是python导入的包名，如（import hello）
                              # 生成的.c文件不受其影响，依然是与.pyx同名的文件，这里生成的.c文件为pyhello.c
                   ["pyhello.pyx"] # 要生成.c文件的.pyx文件
               )
           ],
           compiler_directives = {'language_level': 3}, 
                              # 消除Cython directive 'language_level' not set的警告
           annotate=True,     # 如果为True，则会生成一个HTML文件，用于查看和分析.pyx是如何转化为.c文件的
       )
   )
   ```

   如果在`pyhello.pyx`中没有在开头加入`# distutils: sources = hello.c`，那么`setup.py`应该是下面这样的：
   
   ```python
   from distutils.core import setup
   from distutils.extension import Extension
   from Cython.Build import cythonize
   
   setup(
       name="My hello app",
       ext_modules = cythonize(
           [
               Extension(
                   "hello",
                   ["pyhello.pyx", "hello.c"] # 如果pyhello.pyx中没有在开头加入
                                              # # distutils: sources = hello.c
                                              # 则需要在列表中加入hello.c
               )
           ],
           compiler_directives = {'language_level': 3}, 
           annotate=True,
       )
   )
   ```

   控制台输出编译信息为：

   ```powershell
   Compiling pyhello.pyx because it changed.
   [1/1] Cythonizing pyhello.pyxrunning build_ext
   building 'hello' extension
   creating build
   creating build\temp.win-amd64-3.7
   creating build\temp.win-amd64-3.7\Release
   D:\ProgramData\Anaconda3\Library\mingw-w64\bin\gcc.exe -mdll -O -Wall -DMS_WIN64 -ID:\ProgramData\Anaconda3\include -ID:\ProgramData\Anaconda3\include -c pyhello.c -o build\temp.win-amd64-3.7\Release\pyhello.o
   D:\ProgramData\Anaconda3\Library\mingw-w64\bin\gcc.exe -mdll -O -Wall -DMS_WIN64 -ID:\ProgramData\Anaconda3\include -ID:\ProgramData\Anaconda3\include -c hello.c -o build\temp.win-amd64-3.7\Release\hello.o
   writing build\temp.win-amd64-3.7\Release\hello.cp37-win_amd64.def
   D:\ProgramData\Anaconda3\Library\mingw-w64\bin\gcc.exe -shared -s    build\temp.win-amd64-3.7\Release\pyhello.o build\temp.win-amd64-3.7\Release\hello.o build\temp.win-amd64-3.7\Release\hello.cp37-win_amd64.def -LD:\ProgramData\Anaconda3\libs -LD:\ProgramData\Anaconda3\PCbuild\amd64 -lpython37 -lmsvcr140 -o E:\VSCode\Cython\hello.cp37-win_amd64.pyd
   ```

   同时生成如下文件和文件夹：

   > build                                              <--这是gcc编译链接的文件所存放的位置
   > |    |-temp.win-amd64-3.7
   > |    |    |-Release
   > |    |    |    |-hello.cp37-win_amd64.def
   > |    |    |    |-hello.o
   > |    |    |    |-pyhello.o
   > hello.cp37-win_amd64.pyd           <-- windows中编译好的动态链接库，以供python调用
   > ​                                                        |- linux下编译好的动态链接库是`.so`文件
   > ​                                                        |-`setup.py`的第9行指定了该`.pyx`的文件名
   > pyhello.c                                        <-- 这是Cython编译`pyhello.pyx`生成的C代码
   > pyhello.html                                   <-- 传入`annotate=True`参数后生成的代码
   > ​                                                        |- 如果传入了参数还没有生成，那么删掉以上生成的文件重新编译

   ~~如果要重新运行`python setup.py build_ext -i`生成和编译文件，建议删除以上几个文件和文件夹后再编译，因为如果文件存在，cython将不会再认真编译，控制台只会输出如下内容，这样做应该是为了提高编译速度，只编译修改过的文件：【**貌似是我忘了保存文件了**】~~

   ```powershell
   running build_ext
   ```

6. main.py（在同一目录下编写测试程序main.py）

   ```python
   import hello        # 该名需要与生成的.pyd文件同名，因为是从.pyd中导入的

   pyhello.hello_text(b"ni hao")
   ```
   运行该文件，如果上面步骤都成功了，那么不出意外的显示如下结果：

   ```
   hello ni hao!
   ```

   从这个例子可以看到`.pyx`文件是连接python和c语言的桥梁。

